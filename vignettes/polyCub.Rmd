---
title: "Getting started with polyCub"
author: "Sebastian Meyer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with polyCub}
  %\VignetteEngine{knitr::rmarkdown}
---

```{R setup, include = FALSE, purl = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

<img src="../man/figures/logo.png" align="right" alt="" width="120" />

The R package **polyCub** implements *cubature* (numerical integration)
over *polygonal* domains.
It solves the problem of integrating a continuously differentiable
function f(x,y) over simple closed polygons.

For the special case where the domain is rectangular with sides parallel
to the axes (such as a bounding box), the package
[**cubature**](https://CRAN.R-project.org/package=cubature)
is more appropriate (cf.
[`CRAN Task View: Numerical Mathematics`](https://CRAN.R-project.org/view=NumericalMathematics)).


## Motivation

The **polyCub** package evolved from the need to evaluate integrals of
so-called spatial interaction functions (e.g., a Gaussian or power-law
kernel) over the observation region of a spatio-temporal point process
(Meyer et al, 2012, *Biometrics*,
<https://doi.org/10.1111/j.1541-0420.2011.01684.x>).
Such an observation region is described by a polygonal boundary,
representing, for example, the shape of a country or administrative
district.


## Polygon representations

All of **polyCub**'s cubature methods understand

* `"owin"` from **spatstat**,

* `"gpc.poly"` from package **rgeos** (or **gpclib**), and

* `"SpatialPolygons"` from package **sp**.

Some also support a plain list of lists of vertex coordinates (`"xylist"`).

Note that the integration domain may consist of more than one polygon
(including holes).


## Cubature methods

The following cubature methods are implemented in **polyCub**:

1. **Product Gauss cubature** as proposed by Sommariva and Vianello
   (2007, *BIT Numerical Mathematics*,
   <https://doi.org/10.1007/s10543-007-0131-2>).

2. The simple **two-dimensional midpoint rule** via `as.im.function()` from
   the [**spatstat**](https://CRAN.R-project.org/package=spatstat) package.
  
3. For **radially symmetric functions** $f(x,y) = f_r(\lVert(x-x_0,y-y_0)\rVert)$,
   numerical integration can be made much more efficient via line
   `integrate()` along the boundary of the polygonal domain
   (Meyer and Held, 2014, *The Annals of Applied Statistics*,
   <https://doi.org/10.1214/14-AOAS743>, Supplement B, Section 2.4).

4. For **bivariate Gaussian densities**, integrals over polygons can be
   solved accurately (but slowly) based on a triangulation of the domain
   (via `tristrip()` from the
   [**gpclib**](https://CRAN.R-project.org/package=gpclib) package)
   and combinations of Gaussian cumulative densities (via `pmvnorm()` from
   the [**mvtnorm**](https://CRAN.R-project.org/package=mvtnorm) package).


## Illustration

```{R}
library("polyCub")
```

We consider a function f(x,y) which all of the above
cubature methods can handle: an isotropic zero-mean Gaussian density.
**polyCub** expects the function's implementation `f` to take a two-column
coordinate matrix as its first argument (as opposed to separate arguments
for the x and y coordinates):

```{R example-f}
f <- function (s, sigma = 5)
{
    exp(-rowSums(s^2)/2/sigma^2) / (2*pi*sigma^2)
}
```

We use a simple hexagon as polygonal integration domain,
here specified via an `"xylist"` of vertex coordinates:

```{R example-polygon}
hexagon <- list(
    list(x = c(7.33, 7.33, 3, -1.33, -1.33, 3),
         y = c(-0.5, 4.5, 7, 4.5, -0.5, -3))
)
```

An image of the function and the integration domain can be produced using
**polyCub**'s rudimentary (but convenient) plotting utility:

```{R example, fig.width = 3, fig.height = 2.5}
plotpolyf(hexagon, f, xlim = c(-8,8), ylim = c(-8,8))
```


### 1. Product Gauss cubature: `polyCub.SV()`

The **polyCub** package provides an R-interfaced C-translation of
"polygauss: Matlab code for Gauss-like cubature over polygons"
(Sommariva and Vianello, 2013, <http://www.math.unipd.it/~alvise/software.html>).
The cubature rule is based on Green's theorem and incorporates
appropriately transformed weights and nodes of one-dimensional
Gauss-Legendre quadrature in both dimensions,
thus the name "product Gauss cubature".
It is exact for all bivariate polynomials if the number of cubature nodes
is sufficiently large (depending on the degree of the polynomial).

For the above example, a reasonable approximation is already obtained
with degree `nGQ = 3` of the one-dimensional Gauss-Legendre quadrature:

```{R product-Gauss, echo = -1, fig.show = "hold"}
par(mar = c(3,3,1,2))
polyCub.SV(hexagon, f, nGQ = 3, plot = TRUE)
```

The involved nodes (displayed in the figure above) and weights can be
extracted by calling `polyCub.SV()` with `f = NULL`, e.g., to determine
the number of nodes:
```{R}
nrow(polyCub.SV(hexagon, f = NULL, nGQ = 3)[[1]]$nodes)
```

For illustration, we create a variant of `polyCub.SV()`,
which returns the number of function evaluations as an attribute:

```{R}
polyCub.SVn <- function (polyregion, f, ..., nGQ = 20) {
    nw <- polyCub.SV(polyregion, f = NULL, ..., nGQ = nGQ)
    ## nw is a list with one element per polygon of 'polyregion'
    res <- sapply(nw, function (x)
        c(result = sum(x$weights * f(x$nodes, ...)), nEval = nrow(x$nodes)))
    structure(sum(res["result",]), nEval = sum(res["nEval",]))
}
polyCub.SVn(hexagon, f, nGQ = 3)
```

We can use this function to investigate how the accuracy of the
approximation depends on the degree `nGQ` and the associated number of
cubature nodes:

```{R}
for (nGQ in c(1:5, 10, 20)) {
    result <- polyCub.SVn(hexagon, f, nGQ = nGQ)
    cat(sprintf("nGQ = %2i: %.12f (n=%i)\n", nGQ, result, attr(result, "nEval")))
}
```


### 2. Two-dimensional midpoint rule: `polyCub.midpoint()`

The two-dimensional midpoint rule in **polyCub** is a simple wrapper
around `as.im.function()` and `integral.im()` from package **spatstat**.
In other words, the polygon is represented by a binary pixel image and
the integral is approximated as the sum of (pixel area * f(pixel midpoint))
over all pixels whose midpoint is part of the polygon.

To use `polyCub.midpoint()`, we need to convert our polygon to
**spatstat**'s "owin" class:

```{R, message = FALSE}
library("spatstat")
hexagon.owin <- owin(poly = hexagon)
```

Using a pixel size of `eps = 0.5` (here yielding 270 pixels), we obtain:

```{R midpoint, echo = -1, fig.show = "hold"}
par(mar = c(3,3,1,3), xaxs = "i", yaxs = "i")
polyCub.midpoint(hexagon.owin, f, eps = 0.5, plot = TRUE)
```


### 3. Adaptive cubature for *isotropic* functions: `polyCub.iso()`

A radially symmetric function can be expressed in terms of
the distance r from its point of symmetry: f(r).
If the antiderivative of r times f(r), called `intrfr()`, is
analytically available, Green's theorem leads us to a cubature rule
which only needs one-dimensional numerical integration.
More specifically, `intrfr()` will be `integrate()`d along the edges of
the polygon. The mathematical details are given in
<https://doi.org/10.1214/14-AOAS743SUPPB> (Section 2.4).

For the bivariate Gaussian density `f` defined above,
the integral from 0 to R of `r*f(r)` is analytically available as:
```{R}
intrfr <- function (R, sigma = 5)
{
    (1 - exp(-R^2/2/sigma^2))/2/pi
}
```

With this information, we can apply the cubature rule as follows:

```{R}
polyCub.iso(hexagon, intrfr = intrfr, center = c(0,0))
```

Note that we do not even need the original function `f`.

If `intrfr()` is missing, it can be approximated numerically using
`integrate()` for `r*f(r)` as well, but the overall integration will then
be much less efficient than product Gauss cubature.

Package **polyCub** exposes a C-version of `polyCub.iso()`
for use by other R packages (notably **surveillance**) via
`LinkingTo: polyCub` and `#include <polyCubAPI.h>`.
This requires the `intrfr()` function to be implemented in C as well. See
<https://github.com/bastistician/polyCub/blob/master/tests/testthat/polyiso_powerlaw.c>
for an example.


### 4. Integration of the *bivariate Gaussian density*: `polyCub.exact.Gauss()`

Abramowitz and Stegun (1972, Section 26.9, Example 9) offer a formula for
the integral of the bivariate Gaussian density over a triangle with one
vertex at the origin. This formula can be used after triangulation of
the polygonal domain via `tripstrip()` from the **gpclib** package.
The core of the formula is an integral of the bivariate Gaussian density
with zero mean, unit variance and some correlation over an infinite
rectangle [h, Inf] x [0, Inf], which can be computed accurately using
`pmvnorm()` from the **mvtnorm** package.

For the above example, we obtain:

```{R}
gpclibPermit()  # accept gpclib license (prohibits commercial use)
polyCub.exact.Gauss(hexagon.owin, mean = c(0,0), Sigma = 5^2*diag(2))
```

The required triangulation as well as the numerous calls of `pmvnorm()`
make this integration algorithm quiet cumbersome. For large-scale
integration tasks, it is thus advisable to resort to the general-purpose
product Gauss cubature rule `polyCub.SV()`.

Note: There is also a function `circleCub.Gauss()` to calculate the
integral of an *isotropic* Gaussian density over a *circular* domain
(which requires nothing more than a single call of `pchisq()`).
